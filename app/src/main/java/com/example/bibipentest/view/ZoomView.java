package com.example.bibipentest.view;


import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PaintFlagsDrawFilter;
import android.os.Handler;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;

public class ZoomView extends View {

    public static final int IMAGE_MAX_SIZE = 1000;//加载图片允许的最大size，单位kb
    private float minimal = 100.0f;

    private float screenW;//屏幕宽度
    private float screenH;//屏幕高度

    //单指按下的坐标
    private float mFirstX = 0.0f;
    private float mFirstY = 0.0f;

    //单指离开的坐标
    private float lastMoveX = -1f;
    private float lastMoveY = -1f;

    //两指的中点坐标
    private float centPointX;
    private float centPointY;

    //图片的绘制坐标
    private float translationX = 0.0f;
    private float translationY = 0.0f;

    private float canvas_left = 999999999.0f;
    private float canvas_top = 999999999.0f;

    //图片的原始宽高
    public float primaryW;
    public float primaryH;

    //图片当前宽高
    private float currentW;
    private float currentH;

    private float scale = 1.0f;
    private float maxScale = 4.0f, minScale = 1.0f;

    private Matrix matrix;

    private int mLocker = 0;
    private float fingerDistance = 0.0f;

    public boolean isLoaded = false;
    private boolean isClickInImage = false;

    public Bitmap mtempbitmap;
    public Bitmap mbitmap;
    public Canvas mcanvas;

    public Canvas mbgcanvas;
    public Bitmap mbgtempbitmap;

    PaintFlagsDrawFilter pfd;

    Context context;


    public ZoomView(Context context) {
        super(context);
        this.context = context;
    }

    public ZoomView(Context context, AttributeSet attrs) {
        super(context, attrs);
        this.context = context;
    }

    public ZoomView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        this.context = context;
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        super.onLayout(changed, left, top, right, bottom);
        if (changed) {
            screenW = getWidth();
            screenH = getHeight();
            translationX = (screenW - mbitmap.getWidth() * scale) / 2;
            translationY = (screenH - mbitmap.getHeight() * scale) / 2;

            if (canvas_left == 999999999.0f) {
                canvas_left = translationX;
                canvas_top = translationY;
            }
            Log.d("imageZoomView ", "onLayout " + translationX + "  " + translationY);

            setMaxMinScale();
        }
    }

    /**
     *
     */
    private void setMaxMinScale() {

        minScale = 1.0f;
        maxScale = 4.0f;

        if (isScaleError()) {
            restoreAction();
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (!isLoaded) {
            return true;
        }
        switch (event.getActionMasked()) {
            case MotionEvent.ACTION_DOWN:
                mFirstX = event.getX();
                mFirstY = event.getY();
                isClickInImage();
                break;
            case MotionEvent.ACTION_POINTER_DOWN:
                fingerDistance = getFingerDistance(event);
                isClickInImage(event);
                break;
            case MotionEvent.ACTION_MOVE:
                float fingerNum = event.getPointerCount();
                if (fingerNum == 1 && mLocker == 0 && isClickInImage) {
                    movingAction(event);
                } else if (fingerNum == 2 && isClickInImage) {
                    zoomAction(event);
                }
                break;
            case MotionEvent.ACTION_POINTER_UP:
                mLocker = 1;
                if (isScaleError()) {
                    translationX = (event.getX(1) + event.getX(0)) / 2;
                    translationY = (event.getY(1) + event.getY(0)) / 2;

                    Log.d("imageZoomView ", "ACTION_POINTER_UP " + translationX + "  " + translationY);


                }
                break;
            case MotionEvent.ACTION_UP:
                lastMoveX = -1;
                lastMoveY = -1;
                mLocker = 0;
                if (isScaleError()) {
                    restoreAction();
                }
                break;
        }
        return true;
    }


    /**
     * 移动操作
     *
     * @param event
     */
    private void movingAction(MotionEvent event) {
        float moveX = event.getX();
        float moveY = event.getY();
        if (lastMoveX == -1 || lastMoveY == -1) {
            lastMoveX = moveX;
            lastMoveY = moveY;
        }
        float moveDistanceX = moveX - lastMoveX;
        float moveDistanceY = moveY - lastMoveY;
        translationX = translationX + moveDistanceX;
        translationY = translationY + moveDistanceY;
        Log.d("imageZoomView ", "movingAction " + translationX + "  " + translationY);


        lastMoveX = moveX;
        lastMoveY = moveY;
        invalidate();
    }

    /**
     * 缩放操作
     *
     * @param event
     */
    private void zoomAction(MotionEvent event) {
        midPoint(event);
        float currentDistance = getFingerDistance(event);
        if (Math.abs(currentDistance - fingerDistance) > 1f) {
            float moveScale = currentDistance / fingerDistance;
            scale = scale * moveScale;
            translationX = translationX * moveScale + centPointX * (1 - moveScale);
            translationY = translationY * moveScale + centPointY * (1 - moveScale);

            Log.d("imageZoomView ", "zoomAction " + translationX + "  " + translationY);


            fingerDistance = currentDistance;
            invalidate();
        }
    }

    public void refreshBmp() {
        mtempbitmap = Bitmap.createScaledBitmap(mbitmap, (int) (mbitmap.getWidth() * 2), (int) (mbitmap.getHeight() * 2), true);
        mbgtempbitmap = Bitmap.createScaledBitmap(mbitmap, (int) (mbitmap.getWidth() * 2), (int) (mbitmap.getHeight() * 2), true);

    }


    /**
     * 图片恢复到指定大小
     */
    private void restoreAction() {

        if (scale < minScale) {
            scale = minScale;
        } else if (scale > maxScale) {
            scale = maxScale;
        }
        translationX = translationX - mbitmap.getWidth() * scale / 2;
        translationY = translationY - mbitmap.getHeight() * scale / 2;

        Log.d("imageZoomView ", "restoreAction " + translationX + "  " + translationY);


        invalidate();
    }

    public void initDraw() {
        matrix = new Matrix();

        DisplayMetrics dm = getResources().getDisplayMetrics();
        mbitmap = Bitmap.createBitmap(dm.widthPixels, dm.heightPixels, Bitmap.Config.ARGB_8888);
        mcanvas = new Canvas();
        mcanvas.setDrawFilter(new PaintFlagsDrawFilter(0, Paint.ANTI_ALIAS_FLAG |
                Paint.FILTER_BITMAP_FLAG));
        refreshBmp();
        mcanvas.setBitmap(mtempbitmap);


        mbgcanvas = new Canvas();
        mbgcanvas.setDrawFilter(new PaintFlagsDrawFilter(0, Paint.ANTI_ALIAS_FLAG |
                Paint.FILTER_BITMAP_FLAG));
        mbgcanvas.setBitmap(mbgtempbitmap);


        pfd = new PaintFlagsDrawFilter(0, Paint.ANTI_ALIAS_FLAG | Paint.FILTER_BITMAP_FLAG);

        Handler h = new Handler();
        h.postDelayed(new Runnable() {
            @Override
            public void run() {
                postInvalidate();
            }
        }, 200);
    }


    /**
     * 判断手指是否点在图片内(单指)
     */
    private void isClickInImage() {
        if (translationX <= mFirstX && mFirstX <= (translationX + currentW)
                && translationY <= mFirstY && mFirstY <= (translationY + currentH)) {
            isClickInImage = true;
        } else {
            isClickInImage = false;
        }

        Log.d("imageZoomView ", "isClickInImage " + translationX + "  " + translationY);

    }

    /**
     * 判断手指是否点在图片内(双指)
     * 只要有一只手指在图片内就为true
     *
     * @param event
     */
    private void isClickInImage(MotionEvent event) {
        if (translationX <= event.getX(0) && event.getX(0) <= (translationX + currentW)
                && translationY <= event.getY(0) && event.getY(0) <= (translationY + currentH)) {
            isClickInImage = true;
        } else if (translationX <= event.getX(1) && event.getX(1) <= (translationX + currentW)
                && translationY <= event.getY(1) && event.getY(1) <= (translationY + currentH)) {
            isClickInImage = true;
        } else {
            isClickInImage = false;
        }
    }


    /**
     * 获取两指间的距离
     *
     * @param event
     * @return
     */
    private float getFingerDistance(MotionEvent event) {
        float x = event.getX(1) - event.getX(0);
        float y = event.getY(1) - event.getY(0);
        return (float) Math.sqrt(x * x + y * y);
    }

    /**
     * 判断图片大小是否符合要求
     *
     * @return
     */
    private boolean isScaleError() {

        Log.d("setMaxMinScale ", " restoreAction@@@@@@@@@@ " + minScale + "  " + maxScale + "  " + scale);

        if (scale > maxScale
                || scale < minScale) {
            return true;
        }
        return false;
    }


    /**
     * 获取两指间的中点坐标
     *
     * @param event
     */
    private void midPoint(MotionEvent event) {
        centPointX = (event.getX(1) + event.getX(0)) / 2;
        centPointY = (event.getY(1) + event.getY(0)) / 2;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        Log.d("onDraw ", "zoomview  ");
        super.onDraw(canvas);
        if (isLoaded) {
            imageZoomView(canvas);
        }
    }

    private void imageZoomView(Canvas canvas) {
        currentW = primaryW * scale;
        currentH = primaryH * scale;
        matrix.reset();
        matrix.postScale(scale, scale);//x轴y轴缩放
        peripheryJudge();
        matrix.postTranslate(translationX, translationY);//中点坐标移动

        Log.d("imageZoomView ", "imageZoomView " + translationX + "  " + translationY);
        setLayerType(View.LAYER_TYPE_NONE, null);
        if (pfd != null) {
            canvas.setDrawFilter(pfd);
        }
        canvas.drawBitmap(mtempbitmap, matrix, null);
//        canvas.drawBitmap(mbitmap, matrix, null);
    }

    /**
     * 图片边界检查
     * (只在屏幕内)
     */
    private void peripheryJudge() {

        if (translationX > 0) {
            translationX = 0;
        }
        if (translationY > 0) {
            translationY = 0;
        }
        if ((translationX + currentW) - canvas_left < screenW) {
            translationX = (screenW - currentW + canvas_left) / 2;
        }
        if ((translationY + currentH) - canvas_top < screenH) {
            translationY = screenH - currentH + canvas_top;
        }

        Log.d("imageZoomView ", "peripheryJudge " + translationX + "  " + translationY + "  " +
                screenW + "  " + currentW + "  " + canvas_left + "  " + (mbitmap.getWidth() * 2));

    }


    public void refreshcanvas() {
        currentW = primaryW * scale;
        currentH = primaryH * scale;
        matrix.reset();
        matrix.postScale(scale, scale);//x轴y轴缩放

        Log.d("imageZoomView ", "imageZoomView " + translationX + "  " + translationY);
        setLayerType(View.LAYER_TYPE_NONE, null);
        if (pfd != null) {
            mcanvas.setDrawFilter(pfd);
        }
        mcanvas.drawBitmap(mbgtempbitmap, matrix, null);
    }
}