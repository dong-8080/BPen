package com.example.bibipentest.view;


import android.annotation.SuppressLint;
import android.app.ActionBar;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.View;
import android.widget.TextView;

import androidx.annotation.Nullable;

import android.view.ViewGroup.LayoutParams;

import com.bbb.bpen.model.Paper;
import com.bbb.bpen.model.PointData;
import com.example.bibipentest.R;
import com.example.bibipentest.data.PointManager;

import java.util.ArrayList;
import java.util.List;

// 自定义画图控件
public class DrawingView extends View {

    Paint mDrawpaint;

    // 测试后删除
    Paint mTextpaint;

    PointData lastPoint;
    Canvas mCanvas;
    Bitmap bitmap;
    Bitmap background;
    Context context;

    float page_width;
    float page_height;

    public float page_width_forscreen;
    public float page_height_forscreen;

    private boolean isDrawing = false;
    private List<PointData> pointList = new ArrayList<>();
    private String text = "";


    public DrawingView(Context context) {
        super(context);
        this.context = context;
    }

    public DrawingView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        this.context = context;
    }

    public DrawingView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        this.context = context;
    }


    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        Log.e("Page", "background measure width:" + getMeasuredWidth() + " height" + getMeasuredHeight());
    }

    public void initDraw() {
        //初始化画笔
        mDrawpaint = new Paint(Paint.DITHER_FLAG | Paint.ANTI_ALIAS_FLAG);
        mDrawpaint.setStyle(Paint.Style.STROKE);
        mDrawpaint.setStrokeWidth(5);
        mDrawpaint.setAntiAlias(true); // 抗锯齿
        mDrawpaint.setStrokeJoin(Paint.Join.ROUND);
        mDrawpaint.setStrokeCap(Paint.Cap.ROUND);

        // 测试后删除
        mTextpaint = new Paint(Paint.DITHER_FLAG | Paint.ANTI_ALIAS_FLAG);
        mTextpaint.setStrokeWidth(5);
        mTextpaint.setTextSize(30);


        mCanvas = new Canvas();

        // 获取纸类型 测试样例为正度16K
        Paper paper = new Paper(16);
//        page_width = paper.getWidth();
//        page_height = paper.getHeight();

        // 重新定义纸张类型,根据page的大小,再减去两边的出血线条各3mm
        page_width = 185.f - 6;
        page_height = 260.f - 6;

//        Log.e("PAGE", "page width "+ page_width + " page height " + page_height);

        // 加载背景图片，手动缩放
        // 禁用Android系统的缩放选项，否则会出现图片实际尺寸与图片加载后尺寸不一致
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inScaled = false;
        options.inDensity = DisplayMetrics.DENSITY_DEFAULT;
        options.inTargetDensity = DisplayMetrics.DENSITY_DEFAULT;

        background = BitmapFactory.decodeResource(getResources(), R.drawable.page_colored_blue_oriange, options);

        // 此处screenWidth=1200
        int screenWidth = getResources().getDisplayMetrics().widthPixels;
        int screenHeight = getResources().getDisplayMetrics().heightPixels;

        // background width and height
        int newWidth = screenWidth;
        int newHeight = (int) (background.getHeight() * ((float) newWidth / background.getWidth()));

        float scalingFactor = (float) background.getWidth() / (float) screenWidth;
        Log.e("PAGE", "background width:" + background.getWidth() + " height" + background.getHeight());
        Log.e("PAGE", "screen width:" + screenWidth + " height" + screenHeight);
        Log.e("PAGE", "layout width" + getWidth() + " height" + getHeight());
        Log.e("PAGE", "background scaled width" + newWidth + " height" + newHeight);
        Log.e("PAGE", "background scaler index:" + scalingFactor);

        bitmap = Bitmap.createScaledBitmap(background, newWidth, newHeight, false);
        mCanvas = new Canvas(bitmap);

        page_width_forscreen = newWidth;
        page_height_forscreen = newHeight;

        Log.e("PAGE", "page_width_forscreen " + page_width_forscreen + " page_height_forscreen"
                + page_height_forscreen);

        Log.e("PAGE", "background height " + background.getHeight() + "  width"
                + background.getWidth());

    }

    public void notifyDraw() {
        while (PointManager.getInstance().isContainDrawPoint()) {
            pointList = PointManager.getInstance().getPointDrawList();
            while (pointList.size() > 0) {
                PointData pdata = pointList.get(0);
                if (pdata != null) {
//                    Log.e("onDraw ", "x:" + pdata.get_x() + "mm  y " + pdata.get_y() + "mm"+
//                            " lw:" + pdata.getlinewidth() + " start:" + pdata.isStroke_start() +
//                            " end:"+pdata.isStroke_end());

                    Log.e("OnDraw", "x:" + pdata.get_x() + "mm  y " + pdata.get_y() +
                            " end:" + pdata.isStroke_end() + " start:" + pdata.isStroke_start() +
                            " lw" + pdata.getlinewidth());
                }

                if (pdata == null || pdata.isStroke_end()) {
                    Log.d("onDraw ", "drawData 笔画结束 ");
                    pointList.remove(0);
                } else {
                    // 正常绘制，这里应该判断下纸是是否匹配的
                    // Demo中只需要在正16K纸上进行测试即可
                    pointList.remove(0);

                    if (lastPoint == null || pdata.isStroke_start() == true) {
                        lastPoint = pdata;
                    }

                    float xStart = page_width_forscreen * (pdata.get_x()) / page_width;
                    float yStart = page_height_forscreen * (pdata.get_y()) / page_height;
                    float xEnd = page_width_forscreen * (lastPoint.get_x()) / page_width;
                    float yEnd = page_height_forscreen * (lastPoint.get_y()) / page_height;

                    lastPoint = pdata;

                    // 设定笔粗细
                    float PENWIDTH_MIN = 0.1f;
                    float StrokeWidthFactor = 2f;
                    float pwidth = 0;
                    float s_width = PENWIDTH_MIN + StrokeWidthFactor * pdata.getlinewidth() + pwidth;

                    mDrawpaint.setStrokeWidth(s_width);
                    mDrawpaint.setColor(Color.BLACK);

                    mCanvas.drawLine(xStart, yStart, xEnd, yEnd, mDrawpaint);

                    Log.e("onDraw ", "x " + xStart + "dp  y" + yStart + "dp");
                }
            }
        }
    }

    // 模拟提交，使得字迹变化
    public void notifyReDraw(List<PointData> pointList) {

        while (pointList.size() > 0) {
            PointData pdata = pointList.get(0);
            if (pdata != null) {
            }

            if (pdata == null || pdata.isStroke_end()) {
                Log.d("onDraw ", "drawData 笔画结束 ");
                pointList.remove(0);
            } else {
                // 正常绘制，这里应该判断下纸是是否匹配的
                // Demo中只需要在正16K纸上进行测试即可
                pointList.remove(0);

                if (lastPoint == null || pdata.isStroke_start() == true) {
                    lastPoint = pdata;
                }

                float xStart = page_width_forscreen * (pdata.get_x()) / page_width;
                float yStart = page_height_forscreen * (pdata.get_y()) / page_height;
                float xEnd = page_width_forscreen * (lastPoint.get_x()) / page_width;
                float yEnd = page_height_forscreen * (lastPoint.get_y()) / page_height;

                lastPoint = pdata;

                // 设定笔粗细
                float PENWIDTH_MIN = 0.1f;
                float StrokeWidthFactor = 2f;
                float pwidth = 0;
                float s_width = PENWIDTH_MIN + StrokeWidthFactor * pdata.getlinewidth() + pwidth;

                mDrawpaint.setStrokeWidth(s_width * 2);
                mDrawpaint.setColor(Color.RED);

                mCanvas.drawLine(xStart, yStart, xEnd, yEnd, mDrawpaint);
            }
        }
    }


    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        // View 大小改变时，重新创建Bitmap并关联Canvas
        initDraw();
    }

    public void notifyTextChanged(String text) {
        this.text = text;
        invalidate();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        canvas.drawBitmap(bitmap, 0, 0, null);
        // 测试后删除
        canvas.drawText(text, 80, 80, mTextpaint);

        invalidate();

    }

}
