package com.example.bibipentest.view;


import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;

import androidx.annotation.Nullable;

import com.bbb.bpen.model.Paper;
import com.bbb.bpen.model.PointData;
import com.example.bibipentest.R;

import java.util.ArrayList;
import java.util.List;

public class DrawingView2 extends View {

    Paint mDrawpaint;
    PointData lastPoint;
    Canvas mCanvas;
    Bitmap bitmap;
    Bitmap background;
    Context context;

    float page_width;
    float page_height;

    public float page_width_forscreen;
    public float page_height_forscreen;

    private boolean isDrawing = false;
    private List<PointData> pointList = new ArrayList<>();


    public DrawingView2(Context context) {
        super(context);
        this.context = context;
    }

    public DrawingView2(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        this.context = context;
    }

    public DrawingView2(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        this.context = context;
    }

    public void initDraw() {
        //初始化画笔
        mDrawpaint = new Paint(Paint.DITHER_FLAG | Paint.ANTI_ALIAS_FLAG);
        mDrawpaint.setStyle(Paint.Style.STROKE);
        mDrawpaint.setStrokeWidth(5);
        mDrawpaint.setAntiAlias(true); // 抗锯齿
        mDrawpaint.setStrokeJoin(Paint.Join.ROUND);
        mDrawpaint.setStrokeCap(Paint.Cap.ROUND);

        mCanvas = new Canvas();

        // 获取纸类型 测试样例为正度16K
        Paper paper = new Paper(16);
//        page_width = paper.getWidth();
//        page_height = paper.getHeight();

        // 重新定义纸张类型,根据page的大小,再减去两边的出血线条各3mm
        page_width = 185.f - 6;
        page_height = 260.f - 6;

        Log.e("PAGE", "page width " + page_width + " page height " + page_height);

        //缩放背景图片为屏幕宽度
        background = BitmapFactory.decodeResource(getResources(), R.drawable.page_colored_z16k);

        Log.e("PAGE", "background width " + background.getWidth() + " background height "
                + background.getHeight());

        int screenWidth = getResources().getDisplayMetrics().widthPixels;
        Log.e("PAGE", "screenWidth " + screenWidth);

        int screenHeight = getResources().getDisplayMetrics().heightPixels;
        Log.e("PAGE", "screenHeight " + screenHeight);

        int newWidth = screenWidth;
        int newHeight = (int) (background.getHeight() * ((float) newWidth / background.getWidth()));
        Log.e("PAGE", "new Height :" + newHeight);
//
//        int newHeight = 1702;  // 为啥有计算偏差？
        Log.e("PAGE", "new Width " + newWidth + " new Height " + newHeight);

        bitmap = Bitmap.createScaledBitmap(background, newWidth, newHeight, false);
        mCanvas = new Canvas(bitmap);

        page_width_forscreen = newWidth;
        page_height_forscreen = newHeight;

        Log.e("PAGE", "page_width_forscreen " + page_width_forscreen + " page_height_forscreen"
                + page_height_forscreen);

    }


    public void addPoint(PointData pdata) {
        pointList.add(pdata);
        isDrawing = true;
        onDrawingData();
    }

    public void onDrawingData() {
        Log.d("onDrawingData", "pointList size: " + pointList.size());
        while (pointList.size() > 0) {
            PointData pdata = pointList.get(0);
            if (pdata != null) {
                Log.d("onDrawdrawData ",
                        "p_data x and y:" + pdata.get_x() + pdata.get_y() + "," + "linewidth" +
                                pdata.getlinewidth() + " start:" + pdata.isStroke_start() +
                                " end：" + pdata.isStroke_end());
            }

            if (pdata == null || pdata.isStroke_end()) {
                Log.d("onDraw ", "drawData 笔画结束 ");
                pointList.remove(0);
            } else {
                // 正常绘制，这里应该判断下纸是是否匹配的
                pointList.remove(0);
//                bbbdrawmanager.DrawLine(mCanvas, pdata, mDrawpaint, page_width, page_height,
//                        page_width_forscreen, page_height_forscreen,3+pdata.getlinewidth());


                float width_dangliangbi = (pdata.get_x()) / page_width;
                float height_dangliangbi = (pdata.get_y()) / page_height;


                if (lastPoint == null || pdata.isStroke_start() == true) {
                    lastPoint = pdata;
                }

                float last_width_dangliangbi = (lastPoint.get_x()) / page_width;
                float last_height_dangliangbi = (lastPoint.get_y()) / page_height;

                float xStart = page_width_forscreen * width_dangliangbi;
                float yStart = page_height_forscreen * height_dangliangbi;
                float xEnd = page_width_forscreen * last_width_dangliangbi;
                float yEnd = page_height_forscreen * last_height_dangliangbi;

                lastPoint = pdata;

                // 计算两点之间线的粗细
                float PENWIDTH_MIN = 0.1f;
                float StrokeWidth = 1f;
                float pwidth = 0;
                float s_width = PENWIDTH_MIN + StrokeWidth * pdata.getlinewidth() + pwidth;

                mDrawpaint.setStrokeWidth(s_width);

                mCanvas.drawLine(xStart, yStart, xEnd, yEnd, mDrawpaint);

                Log.d("onDrawing", "xStart = " + xStart + ", XEnd = " + yStart);
            }

        }
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        // View 大小改变时，重新创建Bitmap并关联Canvas
        initDraw();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        canvas.drawBitmap(bitmap, 0, 0, null);
        invalidate();

    }
}
