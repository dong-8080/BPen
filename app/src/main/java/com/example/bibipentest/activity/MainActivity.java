package com.example.bibipentest.activity;

import android.Manifest;
import android.annotation.SuppressLint;
import android.bluetooth.BluetoothGatt;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;


import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.navigation.NavController;
import androidx.navigation.Navigation;
import androidx.navigation.fragment.NavHostFragment;
import androidx.navigation.ui.AppBarConfiguration;
import androidx.navigation.ui.NavigationUI;

import com.bbb.bpen.binder.BiBiBinder;
import com.bbb.bpen.command.BiBiCommand;
import com.bbb.bpen.common.BBBType;
import com.bbb.bpen.delegate.BlueDelegate;
import com.bbb.bpen.model.Pen;
import com.bbb.bpen.model.PointData;
import com.bbb.bpen.service.BluetoothLEService;
import com.example.bibipentest.R;
import com.example.bibipentest.callback.ConnectionInterface;
import com.example.bibipentest.util.Util;
import com.example.bibipentest.view.DrawingView2;
import com.google.android.material.bottomnavigation.BottomNavigationView;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingDeque;


public class MainActivity extends AppCompatActivity {

    static {
        System.loadLibrary("bbbdraw");
    }

    private static final int REQUEST_BLUETOOTH_PERMISSION = 111;
    public static List<PointData> recies_data = new ArrayList<>();

    public static List<PointData> store_data = new ArrayList<>();

    private static String TAG = "blueDelegate";

    public Boolean isBound;
    private BluetoothLEService service = null;

    private Button btn1;
    private Button btn_connect_pen;

    private Button btn_permission;

    // 上一个坐标点
    private TextView textView1;
    private TextView textView2;
    private TextView textView_click;

    private List<List<PointData>> writhingList = new ArrayList<>(); //存储写的一个字(多个笔画)

    private List<PointData> currentStrokeList = new ArrayList<>(); //存储当前写的一个笔画

    private DrawingView2 dw;
    private int firmversion;

    private Handler writingHandler = new Handler(Looper.myLooper()) {
        @Override
        public void handleMessage(@NonNull Message msg) {
            super.handleMessage(msg);
            if (msg.what == 1) {
                Log.e(TAG, "handleMessage: " + msg.obj);
                textView_click.setText(msg.obj.toString());
            }
        }
    };

    Handler updatehandler = new Handler();

    Runnable updaterunnable = new Runnable() {
        @Override
        public void run() {
//            ladapter.notifyDataSetChanged();
            Log.e(TAG, "notifyDataSetChanged called by updaterunnable");
        }
    };

    private ServiceConnection coon = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder binder) {
            isBound = true;
            BiBiBinder myBinder = (BiBiBinder) binder;
            service = myBinder.getService();
            Log.e(TAG, "onServiceConnected " + isBound);
            service.setblueDelegate(blueDelegate);
            Log.e(TAG, "onServiceConnected " + isBound);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            Log.e(TAG, "onServiceDisconnected ");
            isBound = false;
        }
    };

    @SuppressLint("MissingInflatedId")
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);


        Intent intent = new Intent(this, BluetoothLEService.class);

        bindService(intent, coon, Context.BIND_AUTO_CREATE);

        System.loadLibrary("bbbdraw");

        // init view
        btn1 = findViewById(R.id.btn1);
        btn_connect_pen = findViewById(R.id.btn_connect_pen);
        btn_permission = findViewById(R.id.btn_permission);
        dw = findViewById(R.id.drawing);

        textView1 = findViewById(R.id.textView1);
        textView2 = findViewById(R.id.textView2);
        textView_click = findViewById(R.id.textView_click);


        Log.d("Thread", "onCreate: Thread.currentThread() = " + Thread.currentThread());

        btn1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.e(TAG, "onClick: btn1");
                try {
                    Boolean bool = BiBiCommand.startScanWithQueue(MainActivity.this);
                    Log.e(TAG, "startScanWithQueue " + bool);
                } catch (Exception e) {
                    Log.e(TAG, e.toString());
                }

                Log.d("writing", "onClick: btn1, writhingList size = " + writhingList.size() + ", currentStrokeList = " + currentStrokeList);
            }
        });

        btn_connect_pen.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 更简单了，只需要将笔上MAC地址输入，转换一下强制连接即可
                //CFAF08A26A04
                //F6881FB43709
                String mac_address = "F6881FB43709";
                String mac_address_convert = Util.macConvert(mac_address);
                Boolean isconnect = BiBiCommand.connect(MainActivity.this, mac_address_convert, true);
                Log.e(TAG, "是否连接" + isconnect);
            }
        });

        btn_permission.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.e(TAG, "onClick: btn_permission");
                checkBluetoothPermission();
            }
        });

        float backgroundHeight = 5998.f;
        float newWidth = 1200.f;
        float backgroundWidth = 4228.f;
        int newHeight = (int) (backgroundHeight * newWidth / backgroundWidth);
        textView1.setText(newHeight + "");

        //导航栏
        NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment);
        AppBarConfiguration appBarConfiguration =
                new AppBarConfiguration.Builder(navController.getGraph()).build();
        Toolbar toolbar = findViewById(R.id.toolbar);
        NavigationUI.setupWithNavController(
                toolbar, navController, appBarConfiguration);
    }

    ConnectionInterface callback = new ConnectionInterface() {
        @Override
        public void callback(String name, String mac) {
            select_name = name;
            select_mac = mac;
            Toast.makeText(MainActivity.this, "连接设备", Toast.LENGTH_LONG).show();
            BiBiCommand.connect(MainActivity.this, mac, false);// 非实时数据不自动删除
        }
    };

    // 判断蓝牙权限
    private void checkBluetoothPermission() {
        // 检查蓝牙权限是否已授予
        // 写满权限
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH) != PackageManager.PERMISSION_GRANTED ||
                ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_ADMIN) != PackageManager.PERMISSION_GRANTED ||
                ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED ||
                ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_SCAN) != PackageManager.PERMISSION_GRANTED ||
                ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED ||
                ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED

        ) {
            // 权限未被授予，需要申请权限
            Log.e(TAG, "checkBluetoothPermission: 权限未被授予，需要申请权限");
            Toast.makeText(MainActivity.this, "权限未被授予，需要申请权限", Toast.LENGTH_SHORT);
            ActivityCompat.requestPermissions(this, new String[]{
                    Manifest.permission.BLUETOOTH,
                    Manifest.permission.BLUETOOTH_ADMIN,
                    Manifest.permission.BLUETOOTH_CONNECT,
                    Manifest.permission.BLUETOOTH_SCAN,
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.ACCESS_COARSE_LOCATION
            }, REQUEST_BLUETOOTH_PERMISSION);
        } else {
            // 权限已被授予，可以进行蓝牙操作
            Toast.makeText(MainActivity.this, "权限已被授予，可以进行蓝牙操作", Toast.LENGTH_SHORT);
            Log.e(TAG, "checkBluetoothPermission: 权限已被授予，可以进行蓝牙操作");
        }
    }


    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        if (requestCode == REQUEST_BLUETOOTH_PERMISSION) {

            // 0表示授权成功，-1失败，全都为0即成功
            int grantResultsSum = 0;
            for (int grantResult : grantResults) {
                grantResultsSum += grantResult;
            }
            if (grantResults.length > 0 && grantResultsSum == PackageManager.PERMISSION_GRANTED) {
                // 权限已被授予，可以进行蓝牙操作
                Log.e(TAG, "权限已被授予，可以进行蓝牙操作");
                for (int i = 0; i < grantResults.length; i++) {
                    Log.e(TAG, "permission " + permissions[i] + ":" + grantResults[i]);
                }

            } else {
                // 权限被拒绝，无法执行蓝牙操作
                Log.e(TAG, "权限被拒绝，无法执行蓝牙操作");
                // 可以根据需要进行处理，例如显示一个提示信息或关闭应用程序
            }
        }
    }

    com.bbb.bpen.delegate.BlueDelegate blueDelegate = new BlueDelegate() {
        @Override
        public void didDiscoverWithPen(Pen device, int rssi) {
            String mac = device.getAddress();
            Log.e(TAG, "didDiscoverWithPen address " + device.getAddress() + "  " + rssi + "  " + device.getName());
//            if (addDevice(device)) {
//                Log.d("blueDelegate", "notifyDataSetChanged ");
//                ladapter.notifyDataSetChanged();
//            }
        }


        @Override
        public void didConnectFail(BluetoothGatt gatt, int status, int newState) {
//            Toast.makeText(MainActivity.this, "蓝牙断开 " + status + " " + newState, Toast.LENGTH_LONG).show();
            Log.e(TAG, "didDiscoverWithPen status " + status + " newState " + newState);

            updatehandler.postDelayed(updaterunnable, 10);
        }

        @Override
        public void didConnect(Pen device, int i, int i1) {
            Log.e("blueDelegate", "didConnect  connect " + BiBiCommand.isConnect(getApplicationContext()));

            Log.e("blueDelegate", "didConnect  智能笔蓝牙连接成功 " + BiBiCommand.getConnectedDevice());

            Log.d("Thread", "didConnect: Thread.currentThread() = " + Thread.currentThread());
//            textView1.setText("连接状态：蓝牙笔连接成功");
            updatehandler.postDelayed(updaterunnable, 10);
        }

        @Override
        public void didDisconnect(Pen bluetoothDevice, int i, int i1) {
            Log.e("blueDelegate", "Disconnected连接断开  " + BiBiCommand.getConnectedDevice() + i + "  " + i1);
            firmversion = 0;
            devicedisconnect();
            updatehandler.postDelayed(updaterunnable, 10);

            Log.d("Thread", "didDisconnect: Thread.currentThread() = " + Thread.currentThread());
//            textView1.setText("连接状态：蓝牙笔断开连接");
        }


        @Override
        public void notifyBattery(final int battery) {
            // 一直ping，消息太多了，给关掉
//            Log.e("blueDelegate", "notifyBattery 电量 " + battery);

            // TODO：电量显示
//            txt_pow.post(new Runnable() {
//                @Override
//                public void run() {
//                    txt_pow.setText("电量:" + battery + "");
//                }
//            });
//            Intent intent = new Intent(Constant.ACTION_RECIEVE_POW);
//            intent.putExtra("pow", battery);
//            sendBroadcast(intent);
        }


        /**
         * 实时信息，笔的轨迹等
         * pointDrawArray.size() 一直为 1
         * @param pointDrawArray 实时信息
         */
        @SuppressLint("SetTextI18n")
        @Override
        public void notifyRealTimePointData(List<PointData> pointDrawArray) {
//            Log.d("Thread", "notifyRealTimePointData: Thread.currentThread() = " + Thread.currentThread());

            Log.d("writing", "notifyRealTimePointData start writing: size = " + pointDrawArray.size() +
                    ", PointData = " + pointDrawArray);

            for (int i = 0; i < pointDrawArray.size(); i++) {
                Log.d("writing", "notifyRealTimePointData data i = " + i +
                        ", stroke_start = " + pointDrawArray.get(i).isStroke_start() +
                        ", stroke_end = " + pointDrawArray.get(i).isStroke_end() +
                        ", x = " + pointDrawArray.get(i).get_x() +
                        ", y = " + pointDrawArray.get(i).get_y() +
                        ", time_stamp = " + pointDrawArray.get(i).getTime_stamp()
                );

                currentStrokeList.add(pointDrawArray.get(i)); //暂存存储当前点数据

                if (pointDrawArray.get(i).isStroke_start()) { //书写的起点和终点
                    Log.d("writing", "---------writing start");
                } else if (pointDrawArray.get(i).isStroke_end()) {
                    Log.d("writing", "---------writing end");
                }

                // TODO: 2023/7/21 用handler进行处理，本地存储，发送到远程服务器（是否应该在子线程中判断？）
                if (pointDrawArray.get(i).isStroke_end()) {

                    boolean isClickEventFlag = this.isClickEvent(currentStrokeList);

                    Log.d("writing", "writing end, isClickEvent = " + isClickEventFlag);

                    if (!isClickEventFlag) { //判断不是点击事件
                        //存储笔画到writhingList
                        writhingList.add(currentStrokeList);
                    }
                    currentStrokeList.clear(); //清除笔画
                }

                dw.addPoint(pointDrawArray.get(i));
            }

//            Log.e("writing", "end writing, isClickEvent = " + isClickEvent(pointDrawArray));

//            boolean flag = isClickEvent(pointDrawArray);
//            Log.e("Writing", "is click event : " + flag);
//            textView_click.setText("是否点击事件：" + flag);


            // TODO：跳转
//            if (!Constant.isdrawshow) {
//                Intent intent2 = new Intent(ScanActivity.this, DrawActivity.class);
//                intent2.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
//                startActivity(intent2);
//            }

            // TODO:
//            Intent intent = new Intent(Constant.ACTION_RECIEVE_DBUFF);
//            sendBroadcast(intent);

        }

        /**
         * 判断点击事件
         * float x;
         * float y;
         * boolean stroke_start;
         * boolean stroke_end;
         * double time_stamp;
         * 起点的stroke_start为true，stroke_end为false，终点相反
         * 起点的数值有效，终点的数值无效
         * @param pointDrawArray 实时信息
         * @return 是否是点击事件
         */
        private boolean isClickEvent(List<PointData> pointDrawArray) {
            if (pointDrawArray == null || pointDrawArray.size() == 0) {
                return false;
            }

            // 判断起点和终点的时间time_stamp差是否很小
            // FIXME: 2023/7/21 时间戳差值阈值设置
            double timeStampThreshold = 0.5;
            if (pointDrawArray.get(pointDrawArray.size() - 1).getTime_stamp() - pointDrawArray.get(0).getTime_stamp() > timeStampThreshold) {
                return false;
            }

            //判断轨迹pointDrawArray中点的x和y坐标的最大和最小值的差值绝对值是否很小，形成一个长方形，如果长方形很大则不是点击事件
            float minX = Float.MAX_VALUE;
            float maxX = Float.MIN_VALUE;
            float minY = Float.MAX_VALUE;
            float maxY = Float.MIN_VALUE;
            double maxTimeStamp = Float.MIN_VALUE;
            double minTimeStamp = Float.MAX_VALUE;

            // 分别找到x和y的最大和最小值
            for (int i = 0; i < pointDrawArray.size(); i++) {
                if (!pointDrawArray.get(i).isStroke_end()) {
                    minX = Math.min(minX, pointDrawArray.get(i).get_x());
                    maxX = Math.max(maxX, pointDrawArray.get(i).get_x());
                    minY = Math.min(minY, pointDrawArray.get(i).get_y());
                    maxY = Math.max(maxY, pointDrawArray.get(i).get_y());
                    minTimeStamp = Math.min(minTimeStamp, pointDrawArray.get(i).getTime_stamp());
                    maxTimeStamp = Math.max(maxTimeStamp, pointDrawArray.get(i).getTime_stamp());
                }
            }

            // 计算差值
            float xDiff = maxX - minX;
            float yDiff = maxY - minY;
            double timeStampDiff = maxTimeStamp - minTimeStamp;

            // 判断差值是否小于阈值，如果是则认为是点击事件
            // FIXME: 2023/7/19  需要考虑纸张尺寸的大小，阈值应该设置的大一些？
            float distanceThreshold = 1; // 调整这个阈值以适应需求
            Log.d("writing", "isClickEvent:timeStampDiff = " + timeStampDiff + ",xDiff = " + xDiff + ",yDiff = " + yDiff);

            if (xDiff > distanceThreshold || yDiff > distanceThreshold) {
                return false;
            }

            //是点击事件
            return true;
        }

        @Override
        public void notifyBatchPointData(List<PointData> pointDrawArray) {
            Log.d("Thread", "notifyBatchPointData: Thread.currentThread() = " + Thread.currentThread());

            Log.d("notifyBatchPointData", "notifyBatchPointData start writing: size = " + pointDrawArray.size() +
                    ", PointData = " + pointDrawArray.toString());

            for (int i = 0; i < pointDrawArray.size(); i++) {
//                Log.d("blueDelegate", "datanotifyBatchPointData " + " time_stamp " +
//                        pointDrawArray.get(i).getTime_stamp() + "  " + pointDrawArray.get(i).getPage_id() + " paper_type " +
//                        pointDrawArray.get(i).getPaper_type() + " linewidth " +
//                        pointDrawArray.get(i).getlinewidth() + " stroke_start " +
//                        pointDrawArray.get(i).isStroke_start() + " x " +
//                        pointDrawArray.get(i).get_x() + " y " +
//                        pointDrawArray.get(i).get_y() + " Page_no " +
//                        pointDrawArray.get(i).getPage_id() + " islast " +
//                        pointDrawArray.get(i).isStroke_end()+ " Isvirtual " +
//                        pointDrawArray.get(i).isIsvirtual());

                recies_data.add(pointDrawArray.get(i));
            }


//            Intent intent2 = new Intent(ScanActivity.this, DrawActivity.class);
//            intent2.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
//            startActivity(intent2);
//
//            Intent intent = new Intent(Constant.ACTION_RECIEVE_DBUFF);
//            sendBroadcast(intent);
        }

        @Override
        public void notifyFirmwareWithNewVersion(String newVersion) {

//            String versionstr = newVersion.substring(newVersion.lastIndexOf("-") + 1);
//            firmversion = Util.getIntByStr(versionstr);
//            viewupdate(R.id.txt_gujian, "固件版本:" + newVersion);
//
//            BiBiCommand.cameraControl(ScanActivity.this, 1);
            String firmversion = "ADD IT";
            Log.e("blueDelegate ", "notifyFirmwareWithNewVersion 固件版本号  " + newVersion + "  " + firmversion);
        }


        @Override
        public void unsynchronizedDataWithPercentage(float percentage) {
            Log.e("blueDelegate ", "unsynchronizedDataWithPercentage 已使用 百分之  " + percentage + "  ");
//            showToast("已使用  " + percentage + "%");
        }


        @Override
        public void notifySyncComplete() {
            Log.d("blueDelegatecc ", "同步完成 ");
        }

        @Override
        public void notifyDataSynchronizationMode(int mode) {
            // 可能是在线传输和离线传输模式吧
            Log.e("blueDelegatecc ", "notifyDataSynchronizationMode mode " + mode);
//            if(mode == 0){
//                rbtn_realtime.setChecked(true);
//                rbtn_batchtime.setChecked(false);
//            }else{
//                rbtn_realtime.setChecked(false);
//                rbtn_batchtime.setChecked(true);
//            }
        }

        @Override
        public void notifyContinueToUseSuccess() {
            Log.e("disconnect ", "notifyContinueToUseSuccess ");
            updatehandler.postDelayed(updaterunnable, 10);
            deviceconnect();
        }

        @Override
        public void notifyContinueToUseFail() {
            Log.e("disconnect ", "notifyContinueToUseFail ");
            BiBiCommand.disconnect(MainActivity.this);
        }

        @Override
        public void notifyBoundMobile(String mobile) {
            Log.e("disconnect ", "notifyBoundMobile 连接失败  笔已经被尾号是 " + mobile + "手机号绑定了。");
            Looper.prepare();
            Toast.makeText(MainActivity.this, "连接失败，笔已经被尾号是" + mobile + "的手机绑定了。"
                    , Toast.LENGTH_LONG).show();
            Looper.loop();
            BiBiCommand.disconnect(MainActivity.this);
        }

        @Override
        public void accelerometerDataSendFromPenOnXYZ(float x, float y, float z, int jiaodu) {
            Log.e("accelerometer", "accelerometer加速度 x=" + x + " y=" + y + " z=" + z + " 角度=" + jiaodu);

        }

        @Override
        public void notifyWrittingBatchPointData(List<PointData> pointDrawArray) {
            Log.e("notifyWrittingBatchPointData", "notifyWrittingBatchPointData ");
            for (int i = 0; i < pointDrawArray.size(); i++) {
                Log.e("blueDelegate", "notifyWrittingBatchPointData " + " time_stamp " +
                        pointDrawArray.get(i).getTime_stamp() + "  " + pointDrawArray.get(i).getPage_id() + " paper_type " +
                        pointDrawArray.get(i).getPaper_type() + " linewidth " +
                        pointDrawArray.get(i).getlinewidth() + " stroke_start " +
                        pointDrawArray.get(i).isStroke_start() + " x " +
                        pointDrawArray.get(i).get_x() + " y " +
                        pointDrawArray.get(i).get_y() + " Page_no " +
                        pointDrawArray.get(i).getPage_id() + " islast " +
                        pointDrawArray.get(i).isStroke_end());
                recies_data.add(pointDrawArray.get(i));
            }

            // TODO:
//            Intent intent2 = new Intent(ScanActivity.this, DrawActivity.class);
//            intent2.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
//            startActivity(intent2);
//
//            Intent intent = new Intent(Constant.ACTION_RECIEVE_DBUFF);
//            sendBroadcast(intent);
        }

        @Override
        public void notifyOfflineBatchPointData(List<PointData> pointDrawArray, int remainpackage) {
            Log.e("notifyOfflineBatchPointData", "剩余包数 " + remainpackage);
            for (int i = 0; i < pointDrawArray.size(); i++) {
                Log.e("blueDelegate", "notifyOfflineBatchPointData " + " time_stamp " +
                        pointDrawArray.get(i).getTime_stamp() + "  " + pointDrawArray.get(i).getPage_id() + " paper_type " +
                        pointDrawArray.get(i).getPaper_type() + " linewidth " +
                        pointDrawArray.get(i).getlinewidth() + " stroke_start " +
                        pointDrawArray.get(i).isStroke_start() + " x " +
                        pointDrawArray.get(i).get_x() + " y " +
                        pointDrawArray.get(i).get_y() + " Page_no " +
                        pointDrawArray.get(i).getPage_id() + " islast " +
                        pointDrawArray.get(i).isStroke_end());
                recies_data.add(pointDrawArray.get(i));
            }

            // TODO:
//            Intent intent2 = new Intent(ScanActivity.this, DrawActivity.class);
//            intent2.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
//            startActivity(intent2);
//
//            Intent intent = new Intent(Constant.ACTION_RECIEVE_DBUFF);
//            sendBroadcast(intent);
        }

        @Override
        public void notifyCameraState() {
            Log.e("blueDelegate ", "notifyCameraState  摄像头被遮挡 ");
            showToast("摄像头被遮挡");
        }

        @Override
        public void notifyChargeState(int chargestatus) {

            Log.e("disconnect ", "notifyChargeState " + chargestatus);

            if (chargestatus == BBBType.CHARGESTATUS_INCHARGING) {
                showToast("充电中");
            } else if (chargestatus == BBBType.CHARGESTATUS_FULLPOWER) {
                showToast("电量已经充满");
            } else {
                showToast("未充电");
            }

        }

        @Override
        public void notifyModel(String model) {
            Log.e("disconnect ", "notifyModel  型号 " + model);
        }

    };

    public void showToast(String msg) {
        Message message = Message.obtain();
        message.what = 0;
        Bundle bundle = new Bundle();
        bundle.putString("msg", msg);
        message.setData(bundle);
        toasthandler.sendMessage(message);
    }

    Handler devicedisconnecthandler = new Handler();

    public void devicedisconnect() {
        devicedisconnecthandler.post(devicedisconnectrunnable);
    }

    Runnable devicedisconnectrunnable = new Runnable() {
        @Override
        public void run() {
            Log.e("blueDelegate", "未连接智能笔");
//            title_text.setText("未连接智能笔");
//            title_flash.setTextColor(ScanActivity.this.getResources().getColor(R.color.text_grey));
//            title_draw.setTextColor(ScanActivity.this.getResources().getColor(R.color.text_grey));
//            title_discon.setTextColor(ScanActivity.this.getResources().getColor(R.color.text_grey));
        }
    };

    String select_name = "";
    String select_mac = "";

    Handler deviceconnecthandler = new Handler();
    Runnable deviceconnectrunnable = new Runnable() {
        @Override
        public void run() {
            Log.e("blueDelegate", "deviceconnectrunnable:已连接智能笔" + select_name + "mac" + select_mac);
//            title_text.setText("已连接智能笔:name:" + select_name + "mac" + select_mac);
//            title_flash.setTextColor(ScanActivity.this.getResources().getColor(R.color.blue));
//            title_draw.setTextColor(ScanActivity.this.getResources().getColor(R.color.blue));
//            title_discon.setTextColor(ScanActivity.this.getResources().getColor(R.color.blue));
        }
    };

    public void deviceconnect() {
        deviceconnecthandler.post(deviceconnectrunnable);
    }

    @SuppressLint("HandlerLeak")
    Handler toasthandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case 0:
                    Bundle bundle = msg.getData();
                    if (bundle != null) {
                        Toast.makeText(MainActivity.this, bundle.getString("msg", ""), Toast.LENGTH_LONG).show();
                    }
                    break;
                default:
                    break;
            }
        }
    };

}